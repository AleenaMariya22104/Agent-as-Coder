import os
import argparse
import subprocess
import sys
import pandas as pd
import importlib.util

# This is the "brain" of the agent. It contains the logic and the code template
# for the parser that needs to be generated.

# Helper function to create directories if they don't exist
def setup_directories():
    """Creates the necessary directories for the parser and data."""
    print("-> Setting up directory structure...")
    os.makedirs("custom_parsers", exist_ok=True)
    os.makedirs("data/icici", exist_ok=True)
    print("   - Directories 'custom_parsers' and 'data/icici' are ready.")

# --- AGENT'S PLAN & CODE GENERATION ---
def generate_parser_code(target_bank):
    """
    This function represents the agent's core "thought" process.
    It analyzes the requirements and generates the Python code for the parser.

    Plan:
    1. The parser needs to read a PDF file ('icici sample.pdf').
    2. It must extract tabular data from all pages. The table has 5 columns.
    3. The text extraction from PDFs can be messy. Lines might not be uniform.
       A robust regex is needed to capture each part of a transaction.
    4. The regex must identify a date at the start, then a variable-length description,
       followed by optional debit, optional credit, and a final balance amount.
    5. After extraction, the data must be cleaned:
       - Convert Debit/Credit columns to numeric types. Empty values should become NaN.
       - Ensure the final DataFrame schema matches the target CSV:
         ['Date', 'Description', 'Debit Amt', 'Credit Amt', 'Balance'].
    6. The generated code will be written to a new file: 'custom_parsers/icici_parser.py'.
    """
    print(f"-> Agent Planning: Generating a parser for '{target_bank}'...")

    # The agent generates the code as a string template.
    # This code is designed to be robust for the given PDF structure.
    parser_code = f'''
# -*- coding: utf-8 -*-
"""
This script was auto-generated by an AI agent.
It parses ICICI bank statement PDFs into a pandas DataFrame.
"""
import pandas as pd
import pdfplumber
import re
import numpy as np

def parse(pdf_path: str) -> pd.DataFrame:
    """
    Parses the transaction data from an ICICI bank statement PDF.

    Args:
        pdf_path: The file path to the PDF bank statement.

    Returns:
        A pandas DataFrame with the transaction data, matching the
        required schema: ['Date', 'Description', 'Debit Amt', 'Credit Amt', 'Balance'].
    """
    # Regex to capture a transaction line. It looks for:
    # - A date (dd-mm-yyyy) at the start of the line.
    # - A non-greedy description capture.
    # - Three optional, right-aligned numerical values (debit, credit, balance).
    # This handles lines where debit or credit might be empty.
    transaction_regex = re.compile(
    r"^(\d{{2}}-\d{{2}}-\d{{4}})\s+(.*?)\s+([\d,.]*)\s+([\d,.]*)\s+([-\d,.]+)$"
    )

    all_transactions = []
    try:
        with pdfplumber.open(pdf_path) as pdf:
            for page in pdf.pages:
                text = page.extract_text()
                if text:
                    lines = text.split('\\n')
                    for line in lines:
                        match = transaction_regex.match(line)
                        if match:
                            date, desc, debit, credit, balance = match.groups()

                            # Clean up description
                            desc = desc.strip()
                            
                            all_transactions.append([
                                date,
                                desc,
                                debit if debit.strip() else np.nan,
                                credit if credit.strip() else np.nan,
                                balance
                            ])

    except Exception as e:
        print(f"Error processing PDF: {{e}}")
        return pd.DataFrame()

    if not all_transactions:
        print("Warning: No transactions were extracted.")
        return pd.DataFrame()
        
    # Create DataFrame with the correct schema
    df = pd.DataFrame(all_transactions, columns=[
        'Date', 'Description', 'Debit Amt', 'Credit Amt', 'Balance'
    ])

    # --- Data Cleaning and Type Conversion ---
    # Convert amount columns to numeric, coercing errors to NaN
    for col in ['Debit Amt', 'Credit Amt', 'Balance']:
        # Remove commas before converting to numeric
        df[col] = df[col].astype(str).str.replace(',', '', regex=False)
        df[col] = pd.to_numeric(df[col], errors='coerce')
        
    return df

'''
    # Write the generated code to the specified file
    parser_path = "custom_parsers/icici_parser.py"
    try:
        with open(parser_path, "w") as f:
            f.write(parser_code)
        print(f"   - ✅ Success: Parser written to '{parser_path}'")
        return parser_path
    except IOError as e:
        print(f"   - ❌ Error: Failed to write parser file. {e}")
        return None

# --- AGENT'S SELF-TESTING & VERIFICATION ---
def test_parser(parser_path, pdf_path, csv_path):
    """
    Tests the generated parser against the ground-truth CSV.

    This simulates the agent's "self-correction" loop. If this fails, a more
    advanced agent would re-analyze the error and re-generate the code.
    """
    print("-> Agent Testing: Running test on the generated parser...")
    try:
        # Dynamically import the generated parser module
        spec = importlib.util.spec_from_file_location("icici_parser", parser_path)
        icici_parser = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(icici_parser)
        
        # Load expected data from CSV
        expected_df = pd.read_csv(csv_path)
        print("   - Loaded expected results from CSV.")

        # Get actual data from the generated parser
        actual_df = icici_parser.parse(pdf_path)
        print("   - Executed generated parser on PDF.")

        # --- Dataframe normalization for accurate comparison ---
        # Ensure column order is the same
        expected_df = expected_df[actual_df.columns]
        
        # Convert amount columns to numeric for both dataframes to ensure type consistency
        for col in ['Debit Amt', 'Credit Amt', 'Balance']:
           expected_df[col] = pd.to_numeric(expected_df[col].astype(str).str.replace(',', '', regex=False), errors='coerce')
           actual_df[col] = pd.to_numeric(actual_df[col].astype(str).str.replace(',', '', regex=False), errors='coerce')

        # Compare the DataFrames
        if actual_df.equals(expected_df):
            print("\n   - ✅ Test Passed: The parser's output matches the expected CSV exactly.")
            return True
        else:
            print("\n   - ❌ Test Failed: Output does not match the expected CSV.")
            # In a real self-healing agent, we would analyze the diff here.
            print("   - Showing diff for debugging:")
            diff = expected_df.compare(actual_df, align_axis=0)
            print(diff.head())
            return False

    except Exception as e:
        print(f"   - ❌ An exception occurred during testing: {e}")
        return False

# --- CLI & MAIN EXECUTION ---
def main():
    """Main function to run the agent from the command line."""
    parser = argparse.ArgumentParser(description="AI Agent for generating bank statement parsers.")
    parser.add_argument(
        "--target",
        type=str,
        required=True,
        help="The target bank to generate a parser for (e.g., 'icici')."
    )
    args = parser.parse_args()

    if args.target.lower() == 'icici':
        # Define file paths
        pdf_path = "data/icici/icici sample.pdf"
        csv_path = "data/icici/result.csv"
        
        # Verify that the source files exist
        if not os.path.exists(pdf_path) or not os.path.exists(csv_path):
            print(f"Error: Ensure '{pdf_path}' and '{csv_path}' exist.")
            print("Please download them and place them in the correct directory.")
            sys.exit(1)
            
        # 1. Setup environment
        setup_directories()

        # 2. Agent generates the parser code
        parser_path = generate_parser_code(args.target)

        # 3. Agent tests the generated code
        if parser_path:
            # Install dependencies before testing
            print("-> Agent installing dependencies: pandas, pdfplumber...")
            subprocess.check_call([sys.executable, "-m", "pip", "install", "pandas", "pdfplumber", "numpy"])
            
            test_parser(parser_path, pdf_path, csv_path)
    else:
        print(f"Error: Target '{args.target}' is not supported yet.")

if __name__ == "__main__":
    main()